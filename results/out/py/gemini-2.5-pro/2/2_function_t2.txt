As a senior python software engineer, here is my analysis and answer.

### Analysis

1.  **Purpose of `_compact_times()`**: Based on its name and position before the percentile and standard deviation calculations, the `_compact_times()` method most likely serves as a memory optimization. Calculating accurate percentiles requires access to all data points (or a summarized representation of them). For a long-running process, storing every single response time in a list like `self[self.RESP_TIMES]` can consume a very large amount of memory. `_compact_times()` probably converts this raw list into a more memory-efficient data structure (like a histogram or a frequency map) that can still be used for statistical calculations.

2.  **Types of KPIsets**: The question implies two distinct use cases for this `KPIset` object:
    *   **Cumulative KPIset**: This object aggregates data over the entire duration of a process. Its list of response times will grow indefinitely, making it the primary candidate for memory issues.
    *   **Interval KPIset**: This object likely represents data for a small, fixed window of time (e.g., the last second). Its list of response times is naturally bounded by the number of samples that can occur in that short interval and is discarded or archived after the interval passes.

3.  **The Trade-Off**: The decision boils down to a classic trade-off between CPU usage and memory consumption.
    *   **Calling it everywhere**: This ensures all KPIsets have a low memory footprint but adds the CPU overhead of the compaction process to every single interval calculation.
    *   **Calling it only on cumulative sets**: This focuses the optimization where it's most neededâ€”on the object with unbounded memory growth. It avoids spending CPU cycles on short-lived interval objects where the memory usage is unlikely to become a problem.

### Conclusion

The optimization is critical for the cumulative set but is likely a premature and wasteful optimization for interval sets. The CPU overhead of running compaction frequently on small, transient datasets would likely outweigh the minor memory benefits. The correct approach is to target the optimization where the problem actually exists.

<answer>
You should call `compact_times()` only on cumulative KPIsets. The purpose of this function is to manage memory consumption by compressing the large, ever-growing list of response times. This is a critical problem for a cumulative KPIset that aggregates data over a long duration. For interval-based KPIsets, which represent a small and bounded time window, the list of response times does not grow large enough to be a memory concern, and calling `compact_times()` would add unnecessary CPU overhead for minimal benefit.
</answer>