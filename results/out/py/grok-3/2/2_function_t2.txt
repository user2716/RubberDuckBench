Let's analyze the context and purpose of the `compact_times()` method within the provided code to answer the question about whether it should be called on every `KPIset` or only on cumulative `KPIsets`.

From the code snippet, we see that `self._compact_times()` is called at the beginning of the `recalculate` method. The purpose of `recalculate` appears to be updating various statistical metrics (averages, standard deviation, percentiles, etc.) for a set of key performance indicators (KPIs). The method `compact_times()` is likely responsible for preparing or aggregating time-related data before these calculations are performed, as suggested by its name and placement before the statistical computations.

The distinction between "every `KPIset`" and "cumulative `KPIsets`" implies that there might be different types of `KPIset` objects—some that represent individual sets of data and others that represent aggregated or cumulative data over multiple sets or time periods. If `compact_times()` is meant to aggregate or summarize raw timing data into a form suitable for statistical analysis, it might be necessary only for cumulative sets where raw data from multiple sources or periods needs to be consolidated before recalculation. However, if every `KPIset` (individual or cumulative) maintains raw timing data that needs to be compacted before recalculation, then it should be called on all of them.

Without the explicit definition of `compact_times()` or further context about the class structure, I’ll make an educated assumption based on typical design patterns. Since `compact_times()` is called unconditionally in the `recalculate` method (no checks to differentiate between cumulative or individual sets), it suggests that the method is necessary for any `KPIset` instance before recalculating metrics. However, if cumulative `KPIsets` are aggregates of multiple individual sets, and if `compact_times()` is about aggregating raw data, it might be redundant or unnecessary for individual sets if their data is already in a compact form.

Considering best practices, recalculating metrics should ensure data consistency. If `compact_times()` ensures that timing data is in the correct state for accurate calculations, it should be called on every `KPIset` to avoid inconsistencies. But, if the overhead of calling `compact_times()` is significant and unnecessary for individual sets (where data might already be compact), then limiting it to cumulative sets might be more efficient.

Given the lack of explicit context, I lean towards calling it on every `KPIset` as a safer approach to ensure data integrity during recalculation, unless performance considerations or documentation of `compact_times()` suggest otherwise.

<answer>
You should call `compact_times()` on every `KPIset` to ensure that timing data is properly prepared for recalculation of metrics, as it is invoked unconditionally in the `recalculate` method. However, if `compact_times()` is specifically for aggregating data in cumulative `KPIsets` and individual sets do not require this step, you could optimize by limiting the call to cumulative sets, provided this is supported by the method's purpose and documentation.
</answer>