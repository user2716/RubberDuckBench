Let there! Let's dive into the question about whether to call `compact_times()` on every `KPIset` or only on cumulative `KPIsets` in the context of the provided `recalculate()` method.

First, let's understand what `compact_times()` likely does. Although the implementation isn't shown in the provided code segment, the name suggests it compacts or processes time-related data, possibly aggregating or cleaning up stored timestamps or response times in `self._concurrencies` or other internal structures. This operation might be resource-intensive or modify the underlying data used for calculations like averages, percentiles, and standard deviations.

Now, in the context of `KPIset`, we need to consider the difference between individual `KPIsets` and cumulative `KPIsets`. A cumulative `KPIset` likely represents aggregated data over multiple sets or time periods, while a regular `KPIset` might represent data for a single interval or run. If `compact_times()` is meant to reduce memory usage or prepare data for final aggregation, it might be more relevant for cumulative sets where data accumulation is significant. However, if `compact_times()` ensures data consistency or prepares data for the calculations performed in `recalculate()` (like percentiles or averages), it might be necessary for every `KPIset`.

Looking at the code, `self._compact_times()` is called unconditionally at the start of `recalculate()`. This implies that it's currently intended to run for every `KPIset` instance when `recalculate()` is invoked. The subsequent calculations (like averages, percentiles, and standard deviation) depend on the state of the data, which might be altered or prepared by `compact_times()`. If `compact_times()` is critical for ensuring the correctness of data before these calculations, it should indeed be called on every `KPIset`. However, if its purpose is purely optimization (e.g., reducing memory for large datasets in cumulative sets), calling it only on cumulative `KPIsets` might be more efficient, avoiding unnecessary processing for smaller, individual sets.

Without the exact implementation of `compact_times()`, I lean towards calling it on every `KPIset` as a safer default, since it's already coded that way and likely ensures data readiness for the calculations that follow. If performance becomes an issue, profiling could help determine if restricting it to cumulative `KPIsets` is warranted, assuming `compact_times()` is mainly for memory optimization.

<answer>
You should call `compact_times()` on every `KPIset` as it is currently implemented in the `recalculate()` method, ensuring data is properly prepared for subsequent calculations like averages and percentiles. However, if `compact_times()` is primarily for memory optimization and not critical for data correctness, you could consider restricting it to cumulative `KPIsets` after profiling for performance impacts.
</answer>