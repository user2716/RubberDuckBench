<think>
Okay, let's look at the code provided. The function recalculate is part of a KPIset class, and it starts by calling self._compact_times(). The question is whether this method should be called on every KPIset or only cumulative ones.

First, I need to understand what _compact_times does. Since it's called at the beginning of recalculate, it's likely preparing the data for calculations. The recalculate method then computes averages, standard deviation, and percentiles. 

If _compact_times is meant to process or aggregate the response times, maybe it's necessary for all KPIsets. But the question suggests that maybe it's only needed for cumulative sets. 

Looking at the code, the recalculate method uses self[self.RESP_TIMES] and other aggregated metrics. If _compact_times is responsible for consolidating data (like merging multiple runs or sessions), then it might be required for cumulative KPIsets. However, if individual KPIsets already have their data compacted, then calling it again might be redundant. 

But the code doesn't show any conditions on whether _compact_times is called. It's always called first. So maybe the answer is that it should be called on every KPIset, but the question is implying that maybe it's not needed for all. However, without knowing what _compact_times does, it's hard to say. But given that it's called in recalculate, which is part of the KPIset processing, it's likely that it's needed for all KPIsets. However, the question might be suggesting that the code as written calls it on every KPIset, but maybe it should only be called on cumulative ones. 

Wait, the user is asking whether they should call compact_times on every KPIset or only cumulative ones. The code shows that in the recalculate method, compact_times is called regardless. So the answer would depend on the purpose of compact_times. If compact_times is for merging data from multiple sources (like multiple runs), then cumulative KPIsets would need it, but individual ones might not. But if the KPIset is already compacted, then maybe it's not needed. However, the code as written calls it unconditionally. So the answer would be that the code currently calls it on every KPIset, but the decision should be based on whether the KPIset is cumulative. But the question is asking whether it's necessary for all or only cumulative. 

So the answer is that the code currently calls it on every KPIset, but if compact_times is only needed for cumulative sets, then it should be called only in that case. But without knowing what compact_times does, the answer is that the code as written calls it on every KPIset, but the correct approach depends on the logic of compact_times. However, since the question is about whether it's needed for all or only cumulative, the answer would be that it should be called only on cumulative KPIsets, as the code as written might be redundant for individual ones. But the code doesn't have a condition, so the answer is that the code calls it on every KPIset, but the correct approach is to call it only on cumulative ones.
</think>

The code currently calls `compact_times()` unconditionally on every `KPIset`, but the decision to call it should depend on whether the `KPIset` is cumulative. If `compact_times()` is responsible for merging or aggregating data from multiple sources (e.g., multiple runs or sessions), it is only necessary for **cumulative `KPIset` objects** that require such consolidation. For individual `KPIset` instances that already contain pre-processed data, calling `compact_times()` would be redundant. Thus, the correct approach is to call `compact_times()` **only on cumulative `KPIset` objects**, not on every `KPIset`. The code as written may need to be adjusted to include a condition checking if the `KPIset` is cumulative before invoking `compact_times()`. 

<answer>Call `compact_times()` only on cumulative `KPIset` objects, as it is likely responsible for merging data from multiple sources, which is unnecessary for individual `KPIset` instances.</answer>